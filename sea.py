from flask import Flask, render_template, request, redirect, url_for, session
import datetime
from sq_search import *
import re
from secrets import sec_key



app = Flask(__name__)
app.secret_key= sec_key
app.config['SEND_FILE_MAX_AGE_DEFAULT']=0
app.config['TEMPLATES_AUTO_RELOAD']=True # Ensures always fresh template with drop-down list rendered- the lateest generated by function based on user input #
app.config['SESSION_PERMANENT']=False





@app.route('/')
def home():
    session.clear()
# Clearing session on each route to ensure variables are reset before each enquiry #
    return render_template("home.html")



@app.route('/seng/', methods=['GET'])
def seng():
    
    search_options_title="Chosen search options:"

# Using 'try except' block to avoid errors- in case user presses go back or refreshes the
# page the script will execute further and eventually clear session letting
# the user start new search rather than returning an error
   
    if not "search_type" in session:
        try:
            
            if request.method=="GET":
                
                session["search_type"]=request.args.get("stype")
                
                if session.get("search_type") == 'name':
                   
                    search_options=[">Chosing by Name"]
                    return render_template("seng.html", pic1="pic1.html", search_options=search_options_title+"<br><br>", search_by=search_options[0],
                                                choice2="choice2.html")

                if session.get("search_type") == 'ticker':
                    
                    search_options=[">Chosing by ticker"]
                    return render_template("seng.html", pic1="pic1.html", search_options=search_options_title+"<br><br>", search_by=search_options[0],
                                                choice2="choice2tick.html")
        except:
            pass



    if not session.get("namesearch") in session and session.get("search_type") == 'ticker':

        try:
        
            search_options=[">Chosing by ticker"]
            if request.method=="GET":

                session["ticker_search"]=request.args.get("tickersearch").upper()
                get_ticker(session.get("ticker_search"))
                

                if session.get("ticker_result") != None:
                        
                        return redirect(url_for('final_stage'))

                else:
                    
                    notick_error="<p style='font-size: 1.4vw;color: red'>Ticker incorrect! Inster S&P 500 ticker, search again by name or browse all companies from main menu</p>"
                    return render_template("seng.html", pic1="pic1.html", search_options=search_options_title+"<br><br>", search_by=search_options[0],
                                                    choice2="choice2tick.html", notick_error=notick_error)
        except: 
            pass

    
    
    if not session.get("namesearch") in session and session.get("search_type")=="name":
        try:

            if request.method=="GET":
            
                session["namesearch"]=request.args.get("namesearch")
                
                if "namesearch" in session:
                
                    get_names(session.get("namesearch"))

                    if "results" in session and len(session.get("results")) > 0:
                        
                        list_creator(session.get("results")) # Creates HTML script with drop down list of all matches #
                        search_options=[">Chosing by Name"]
                        search_options.append(session.get("namesearch"))
                        number_of_options=f"<br><p style='font-size: 1.3vw'>Number of matching results: {len(session.get('results'))}</p>"
                        
                        
                        return render_template("seng.html",pic1="pic1.html", pic2="pic2.html", search_options=search_options_title+"<br><br>", 
                                                search_by=search_options[0]+"<br><br>", search_name=">Look for: '"+search_options[1]+"'<br>",
                                                number_of_options=number_of_options, choice3="choice3.html")
                        
                    else:
                        
                        noname_error= "<br><p style='font-size: 1.4vw;color: red'>No matches- no such company in S&P 500. Broaden the search or browse all companies in main menu</p>"
                        search_options=[">Chosing by Name"]
                        
                        return render_template("seng.html", pic1="pic1.html", search_options=search_options_title+"<br><br>", search_by=search_options[0],
                                                choice2="choice2.html", noname_error=noname_error)
        except:
            pass


    
    if not "final_name" in session and "results" in session and len(session.get("results")) > 0:

        try:
            if request.method=="GET":
                final_name=request.args.get("name_final")
                session["name_result"]=get_all_byname(final_name) # Function retrives full data based on final user choice from drop down list #
                return redirect(url_for('final_stage'))
        except:
            pass

    
        
    session.clear()
    return render_template("seng.html", choice1="choice1.html")
        
    


def get_names(searched_name):
   
    searched_name=("%"+searched_name+"%") # Formatting for SQL purposes(using LIKE %value% query for all matches) #
    session["results"] = find_names_in_db(searched_name)



def get_ticker(ticker):

    process = find_ticker(ticker)
    session["ticker_result"]=process




# This function will read template HTML file to create list of results based on given word and transform it to drop list 
# to make final selection in next step of search; function will iterate through template, add passed names of companies
# and create new HTML template to be used on the website- including found names

def list_creator(results):

    key='<option value="xx">xx</option>'  # Based on this key function will add/substract selection fields- default is 5
    marker="xx"   # Function will know where to input passed company names
    count=len(results)

# with codecs.open("templates\choice3template.html", "r", encoding='utf-8') as f:
    #  template_html = f.readlines()

    with app.open_resource("templates/choice3template.html", "r") as f:
        template_html = f.readlines()

# Creating list with lines of template html file
    html_code_lines=[]

    for line in template_html:
        strip_line=line.strip()
        html_code_lines.append(strip_line)

    key_count=5 

   
# Default number of keys: 5; if number of results the same: pass
    if key_count == count:
        pass


# Adding/removing amount of selection fields depending on amount of results passed
    if key_count < count:
        add_key=count - key_count
      
        for number_of_inserts in range(add_key):
            html_code_lines.insert(4,key)
      

    if key_count > count:
        minus_key = key_count - count
      
        for number_of_subtractions in range(minus_key):
            html_code_lines.remove(key)
      
# Opening output html file, replacing markers with actual names from list of results and adding to list which is written in HTML file
    template_var=open("templates/choice3.html", "w")
    html_ready_list=[]
    iteration_count=0 # Count of each iteration- passed to list of result to input 1 by 1
   

    for line in html_code_lines:
        if key in line:
            line=re.sub(marker, results[iteration_count] , line)
            iteration_count = iteration_count+1
        
        html_ready_list.append(line)
        template_var.write(line+"\n")
        template_var.flush()
    
    template_var.close()




@app.route('/about/')
def about():
    session.clear()
    
    return render_template("about.html")




@app.route('/final_stage/', methods=['GET'])
def final_stage():
    

    try:
        
        if "name_result" in session:
            session["company"]= session.get("name_result")
        else:
            session["company"]= session.get("ticker_result")


        firm_name=session.get("company")[2]
        info=f"<b>{firm_name}</b> was founded in <b>{session.get('company')[5]}</b> and operates in <b>{session.get('company')[3]}</b> sector. It's stock exchange ticker is <b>{session.get('company')[1]}</b> and Head Quarters are located in <b>{session.get('company')[4]}</b> (city, state/country)."
        max_start_date= datetime.date.today() - datetime.timedelta(days=3) # Setting up max start date to 3 days before today

        
        if not "from_date" in session and session.get("disable_1st") == None:
        
            if request.method == 'GET':
                session["from_date"]=request.args.get("from_date")
                
                if "from_date" in session and session.get("from_date") != None:
                    session["disable_1st"]='disabled=True'
                    return render_template("final_stage.html", firm_name=firm_name, info=info, max_start_date=max_start_date, disable_1st=session.get("disable_1st"), from_date=session.get("from_date"), final2="final_stage2.html")
        

        if not "to_date" in session and session.get("disable_1st") != None:
            
            if request.method == 'GET':
                session["to_date"]=request.args.get("to_date")

                if session.get("to_date") != None:
                    return redirect(url_for('submit_page'))
                        
        
        session.pop("from_date", None)
        session.pop("disable_1st", None)
        session.pop("to_date", None)
        return render_template("final_stage.html", firm_name=firm_name, info=info, max_start_date=max_start_date)
# Avoiding potential errors on page down click or refresh by clearing a session #
    except:
        session.pop("from_date", None)
        session.pop("disable_1st", None)
        session.pop("to_date", None)
        return render_template("final_stage.html", firm_name=firm_name, info=info, max_start_date=max_start_date)




@app.route('/submit_page/', methods=["GET"])
def submit_page():
    
    try:
    
        submit_text= f"Your chosen time span for <b>{session.get('company')[2]}</b> stock price chart is <b>{session.get('from_date')}</b> to <b>{session.get('to_date')}</b>. Please input your email address to receive interactive graph and click <b>Submit</b>. Graph will be also generated on the next page."

        if request.method=="GET":
            session["email_name"]=request.args.get("email_name")

            if session.get("email_name") != None:
                
                session['ready_from_date']=date_format(session.get('from_date'))
                session['ready_to_date']=date_format(session.get('to_date'))

                return redirect(url_for('plot'))


        return render_template("submit_page.html", submit_text=submit_text)

    except:
        return redirect(url_for('seng'))



# Function adapting date input into format used in datareader #
def date_format(date):
    date=date.split("-")

    for place_number, date_element in enumerate(date):

        if date_element.startswith("0"):
            formated_element=date_element.replace("0","")
            date[place_number]=formated_element

    date_ready=date

    return date_ready
   



@app.route('/plot/')
def plot():
    
    from pandas_datareader import data
    from bokeh.plotting import figure, save, output_file
    from bokeh.embed import components 
    from bokeh.resources import CDN
    from bokeh.models import WheelZoomTool
    from send_plot import send_plot

    try:

# Adapting date format for datareader enquiry #
        start=datetime.datetime(int(session.get("ready_from_date")[0]),int(session.get("ready_from_date")[1]),int(session.get("ready_from_date")[2]))
        end=datetime.datetime(int(session.get("ready_to_date")[0]),int(session.get("ready_to_date")[1]),int(session.get("ready_to_date")[2]))
        df=data.DataReader(name=session.get("company")[1], data_source="yahoo", start=start,end=end)
        

        def inc_dec(c,o):
            if c > o:
                value="Increase"
            elif c<o:
                value="Decrease"
            else:
                value="Equal"
            return value


        df["Status"]=[inc_dec(c,o) for c,o in zip(df.Close,df.Open)]
        df["Height"]=abs(df.Close-df.Open)
        df["Middle"]=(df.Open+df.Close)/2

        p=figure(x_axis_type='datetime', width=600, height=300, sizing_mode="scale_width", toolbar_location='right')
        p.outline_line_width=2
        p.outline_line_color='#444'
        p.outline_line_alpha=.8
        p.background_fill_color='blanchedalmond'
        p.border_fill_color='blanchedalmond'
        p.title.text=f"Candle chart- {session.get('company')[2]}"
        p.grid.grid_line_alpha=0.6
        p.title.text_font_size='22px'
        p.title.align='center'
        p.title.text_color="black"
        p.xaxis.axis_label= f'DATE from {session.get("from_date")} to {session.get("to_date")}'
        p.yaxis.axis_label= 'PRICE ($)'
        p.yaxis.ticker.desired_num_ticks = 6
        p.xaxis.ticker.desired_num_ticks = 15
        p.toolbar.active_scroll=p.select_one(WheelZoomTool)

        hours_12=12*60*60*1000

        p.segment(df.index,df.High,df.index,df.Low, color="black")
        p.rect(df.index[df.Status=="Increase"],df.Middle[df.Status=="Increase"], hours_12, df.Height[df.Status=="Increase"], fill_color="#7CFC00", 
            line_color="black")
        p.rect(df.index[df.Status=="Decrease"], df.Middle[df.Status=="Decrease"], hours_12, df.Height[df.Status=="Decrease"], fill_color="red", 
            line_color="black")
        p.line(df.index,df.Middle, line_width=1.5, color='black', line_alpha=.3, line_join='miter', legend_label="Trend")

        output_file("new_plot.html")
        save(p)
        script1, div1, =components(p)

        cdn_js=CDN.js_files[0]

        send_plot(session.get('email_name'), session.get("company")[2], session.get('from_date'), session.get('to_date'))

        final_message="<p><br> Thank you! You can browse selected graph below- zoom in and out for more detailed info. You can use your mouse wheel if you hover over the graph. The graph was also sent to given e-mail address in HTML format. Navigate menu on the top for a new search.</p><br>"
        
        session.clear()
        return render_template("plot.html", script1=script1, div1=div1, cdn_js=cdn_js, final_message=final_message)

    except:
        return redirect(url_for('seng'))




@app.route('/browseall/', methods=["GET"])
def browseall():
    session.clear()

    company_list = browse_all()
    try:
        
        if request.method == 'GET':
            letter=request.args.get("letter")

            if letter=="all":
                return render_template("browseall.html", company_list=company_list)

            if letter != None:
                letter=(letter+"%")
                company_list=starts_with_letter(letter)

                return render_template("browseall.html", company_list=company_list)
    except:
        pass

    return render_template("browseall.html", company_list=company_list)





if __name__ == "__main__":
    app.run(debug=True)